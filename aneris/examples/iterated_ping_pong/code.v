(* From aneris.aneris_lang Require Import lang notation. *)
(* From aneris.aneris_lang.lib Require Export network_util assert list. *)

(* (* Iterated Ping Pong *)
(*  * In this example, we have N + 1 nodes: a server and N clients. *)
(*  * The server sends every client a single "PING" message. *)
(*  * Each client listens for incoming messages, and replies *)
(*  * with a single "PONG" message. *)
(*  *) *)

(* (* Server code. Arguments: *)
(*  *   - "my_addr": the server's address *)
(*  *   - "client_addrs": a list of client addresses. *)
(*  *     lists are represented as in Aneris' list library. *)
(*  * *)
(*  * Note that the server doesn't wait for clients to respond before *)
(*  * it pings other clients. *)
(*  *) *)
(* Definition server : base_lang.val := *)
(*   λ: "my_addr" "client_addrs", *)
(*   let: "socket" := NewSocket #Network.PF_INET *)
(*                              #Network.SOCK_DGRAM *)
(*                              #Network.IPPROTO_UDP in *)
(*   SocketBind "socket" "my_addr";; *)
(*   list_iter (λ: "client_addr", *)
(*               SendTo "socket" #"PING" "client_addr") *)
(*             "client_addrs". *)

(* (* Client code. The client waits for a "PING" message and *)
(*  * then just replies with a "PONG". *)
(*  * Arguments: *)
(*  *   - "my_addr": the client's address *)
(*  *) *)
(* Definition client : base_lang.val := *)
(*   λ: "my_addr", *)
(*   let: "socket" := NewSocket #Network.PF_INET *)
(*                              #Network.SOCK_DGRAM *)
(*                              #Network.IPPROTO_UDP in *)
(*   SocketBind "socket" "my_addr";; *)
(*   let: "m" := unSOME (ReceiveFrom "socket") in *)
(*   let: "msg" := Fst "m" in *)
(*   let: "sender" := Snd "m" in *)
(*   (if: "msg" = #"PING" *)
(*    then SendTo "socket" #"PONG" "sender" *)
(*    else assert #false). *)

(* (* Port for all nodes in the example. *) *)
(* Definition port := 80. *)

(* Definition runner : base_lang.expr := *)
(*   let: "client1" := MakeAddress #"0.0.0.1" #port in *)
(*   let: "client2" := MakeAddress #"0.0.0.2" #port in *)
(*   let: "client3" := MakeAddress #"0.0.0.3" #port in *)
(*   let: "client_addrs" := *)
(*      list_cons "client1" *)
(*                (list_cons "client2" *)
(*                           (list_cons "client3" *)
(*                                      list_nil)) in *)
(*   Start "0.0.0.1" (client "client1");; *)
(*   Start "0.0.0.2" (client "client2");; *)
(*   Start "0.0.0.3" (client "client3");; *)
(*   let: "server_addr" := MakeAddress #"0.0.0.99" #port in *)
(*   Start "0.0.0.99" (server "server_addr" "client_addrs"). *)

(* (* *)
(* TODO: `Start` currently takes a base_lit as an argument. *)
(* If we change `Start` to take a base_lang.expr, then we can spawn nodes *)
(* programatically using the helpers below. *)

(* Definition make_ip_addr_pairs : base_lang.val := *)
(*   λ: "ips", *)
(*   let: "rev_res" := *)
(*      list_fold (λ: "acc" "pair", list_cons (Snd "pair") "acc") *)
(*                (list_make #()) *)
(*                "ips" *)
(*   in *)
(*   list_rev "rev_res". *)

(* Definition start_clients : base_lang.val := *)
(*   λ: "ip_addr_pairs", *)
(*   list_iter (λ: "ip_addr_pair", *)
(*              Start (Fst "ip_addr_pair") *)
(*                    (client (Snd "ip_addr_pair"))) *)
(*             "ip_addr_pairs". *)
(* *) *)
