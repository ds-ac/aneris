(* This file is automatically generated from the OCaml source file
<repository_root>/ml_sources/examples/dscm/implementations/one_server/one_server_server_code.ml *)

From aneris.aneris_lang Require Import ast.
From aneris.aneris_lang.lib Require Import list_code.
From aneris.aneris_lang.lib Require Import queue_code.
From aneris.aneris_lang.lib Require Import map_code.
From aneris.aneris_lang.lib Require Import network_util_code.
From aneris.examples.dscm.implementations.one_server Require Import one_server_network_code.

Definition emit_reply : val :=
  λ: "lk" "outQ" "reply",
  acquire "lk";;
  "outQ" <- (queue_add "reply" ! "outQ");;
  release "lk".

Definition commit_op : val :=
  λ: "ctable" "db" "req",
  let: "rop" := Fst (Fst "req") in
  let: "rid" := Snd (Fst "req") in
  let: "caddr" := Snd "req" in
  let: "res" := match: "rop" with
    InjL "p" =>
    let: "k" := Fst "p" in
    let: "v" := Snd "p" in
    "db" <- (map_insert "k" "v" ! "db");;
    InjL #()
  | InjR "k" => InjR (map_lookup "k" ! "db")
  end in
  "ctable" <- (map_insert "caddr" ("rid", (SOME "res")) ! "ctable");;
  ("res", "rid", "caddr").

Definition process_new_request : val :=
  λ: "lk" "log" "ctable" "db" "outQ" "req",
  let: "_rop" := Fst (Fst "req") in
  let: "rid" := Snd (Fst "req") in
  let: "caddr" := Snd "req" in
  "ctable" <- (map_insert "caddr" ("rid", NONE) ! "ctable");;
  "log" <- (list_append ! "log" ["req"]);;
  let: "reply" := commit_op "ctable" "db" "req" in
  emit_reply "lk" "outQ" "reply".

Definition process_request : val :=
  λ: "log" "ctable" "db" "lk" "outQ" "req",
  let: "_rop" := Fst (Fst "req") in
  let: "rid" := Snd (Fst "req") in
  let: "caddr" := Snd "req" in
  match: map_lookup "caddr" ! "ctable" with
    NONE => process_new_request "lk" "log" "ctable" "db" "outQ" "req"
  | SOME "p" =>
      let: "t" := Fst "p" in
      let: "ro" := Snd "p" in
      (if: "rid" < "t"
       then  #()
       else
         match: "ro" with
          NONE => assert: ("rid" = "t")
        | SOME "res" =>
            (if: "rid" = "t"
             then  emit_reply "lk" "outQ" ("res", "rid", "caddr")
             else
               assert: ("rid" = ("t" + #1));;
               process_new_request "lk" "log" "ctable" "db" "outQ" "req")
        end)
  end.

Definition fetch_request : val :=
  λ: "lk" "inQ",
  acquire "lk";;
  let: "tmp" := ! "inQ" in
  (if: ~ (queue_is_empty "tmp")
   then
     let: "q" := unSOME (queue_take_opt "tmp") in
     let: "hd" := Fst "q" in
     let: "tl" := Snd "q" in
     "inQ" <- "tl";;
     #();;
     release "lk";;
     SOME "hd"
   else  NONE).

Definition request_loop : val :=
  λ: "log" "ctable" "db" "lk" "inQ" "outQ",
  letrec: "loop" <> :=
    let: "req_opt" := fetch_request "lk" "inQ" in
    match: "req_opt" with
      NONE =>
      #() (* unsafe (fun () -> Unix.sleepf 0.5); loop () *);;
      "loop" #()
    | SOME "req" =>
        process_request "log" "ctable" "db" "lk" "outQ" "req";;
        "loop" #()
    end in
    "loop" #().

Definition init_server val_ser : val :=
  λ: "srv",
  let: "log" := ref [] in
  let: "ctable" := ref (map_empty #()) in
  let: "db" := ref (map_empty #()) in
  let: "netdata" := init_network val_ser "srv" in
  let: "lk" := Fst (Fst "netdata") in
  let: "inQ" := Snd (Fst "netdata") in
  let: "outQ" := Snd "netdata" in
  request_loop "log" "ctable" "db" "lk" "inQ" "outQ".
