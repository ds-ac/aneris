(* This file is automatically generated from the OCaml source file
<repository_root>/ml_sources/examples/viewstamped_replication/vr_replica_code.ml *)

From aneris.aneris_lang Require Import ast.
From aneris.aneris_lang.lib Require Import list_code.
From aneris.aneris_lang.lib Require Import queue_code.
From aneris.aneris_lang.lib Require Import map_code.
From aneris.aneris_lang.lib Require Import network_util_code.
From aneris.examples.viewstamped_replication Require Import vr_serialization_code.
From aneris.examples.viewstamped_replication Require Import vr_network_code.
From aneris.examples.viewstamped_replication Require Import vr_debug.

(**  Serialization  *)

Definition emit : val :=
  λ: "lk" "outQ" "event",
  acquire "lk";;
  "outQ" <- (queue_add (InjL "event") ! "outQ");;
  release "lk".

Definition emit_rpl : val :=
  λ: "lk" "outQ" "event",
  acquire "lk";;
  "outQ" <- (queue_add (InjR "event") ! "outQ");;
  release "lk".

(**  -------------------------------------------------------------------------  *)

(**  -------------- NORMAL CASE PROCESSING OF CLIENT REQUESTS ----------------  *)

(**  -------------------------------------------------------------------------  *)

Definition commit_op : val :=
  λ: "cmtN" "ctable" "db" "req",
  let: "op" := Fst (Fst "req") in
  let: "c" := Snd (Fst "req") in
  let: "s" := Snd "req" in
  let: "ctbl" := ! "ctable" in
  let: "res" := match: "op" with
    InjL "p" =>
    let: "k" := Fst "p" in
    let: "v" := Snd "p" in
    "db" <- (map_insert "k" "v" ! "db");;
    SOME "v"
  | InjR "k" => map_lookup "k" ! "db"
  end in
  "cmtN" <- (! "cmtN" + #1);;
  let: "ctbl'" := match: map_lookup "c" "ctbl" with
    NONE => assert: #false
  | SOME "p" =>
      (if: (Fst "p") ≤ "s"
       then  map_insert "c" ("s", (SOME "res")) "ctbl"
       else  "ctbl")
  end in
  "ctable" <- "ctbl'";;
  ("res", "c", "s").

Definition commit_oplist_at_primary : val :=
  λ: "cmtN" "ctable" "db" "oplist" "vi" "lk" "outQ",
  letrec: "aux" "l" :=
    match: "l" with
      NONE => #()
    | SOME "p" =>
        let: "op" := Fst "p" in
        let: "tl" := Snd "p" in
        let: "cmtop" := commit_op "cmtN" "ctable" "db" "op" in
        let: "r" := Fst (Fst "cmtop") in
        let: "c" := Snd (Fst "cmtop") in
        let: "s" := Snd "cmtop" in
        emit_rpl "lk" "outQ" (rpl "vi" "s" "r" "c");;
        "aux" "tl"
    end in
    "aux" "oplist".

Definition commit_oplist_at_backup : val :=
  λ: "cmtN" "ctable" "db" "oplist",
  letrec: "aux" "l" :=
    match: "l" with
      NONE => #()
    | SOME "p" =>
        let: "op" := Fst "p" in
        let: "tl" := Snd "p" in
        commit_op "cmtN" "ctable" "db" "op";;
        #();;
        "aux" "tl"
    end in
    "aux" "oplist".

Definition add_ptable_entry : val :=
  λ: "len" "ptable" "orig" "ni",
  let: "okl" := list_init "len" (λ: "_i", ref #false) in
  let: "oki" := unSOME (list_nth "okl" "orig") in
  "oki" <- #true;;
  "ptable" <- (map_insert "ni" ((ref #1), "okl") ! "ptable").

Definition ctbl_add_pending : val :=
  λ: "log_suf" "ctable",
  letrec: "aux" "l" :=
    match: "l" with
      NONE => #()
    | SOME "p" =>
        let: "req" := Fst "p" in
        let: "tl" := Snd "p" in
        let: "_op" := Fst (Fst "req") in
        let: "c" := Snd (Fst "req") in
        let: "s" := Snd "req" in
        "ctable" <- (map_insert "c" ("s", NONE) ! "ctable");;
        "aux" "tl"
    end in
    "aux" "log_suf".

Definition ctbl_ptbl_add_pending : val :=
  λ: "len" "i" "log_suf" "ctable" "ptable" "n",
  letrec: "aux" "l" "nj" :=
    match: "l" with
      NONE => #()
    | SOME "p" =>
        let: "req" := Fst "p" in
        let: "tl" := Snd "p" in
        let: "_op" := Fst (Fst "req") in
        let: "c" := Snd (Fst "req") in
        let: "s" := Snd "req" in
        "ctable" <- (map_insert "c" ("s", NONE) ! "ctable");;
        add_ptable_entry "len" "ptable" "i" "nj";;
        "aux" "tl" ("nj" + #1)
    end in
    "aux" "log_suf" "n".

Definition ctbl_remove_pending : val :=
  λ: "log_suf" "ctable",
  let: "ctbl" := ! "ctable" in
  letrec: "aux" "l" :=
    match: "l" with
      NONE => #()
    | SOME "p" =>
        let: "req" := Fst "p" in
        let: "tl" := Snd "p" in
        let: "_op" := Fst (Fst "req") in
        let: "cl_saddr" := Snd (Fst "req") in
        let: "_seqid" := Snd "req" in
        match: map_lookup "cl_saddr" "ctbl" with
          NONE => #()
        | SOME "q" =>
            let: "_sa" := Fst "q" in
            let: "resp_opt" := Snd "q" in
            match: "resp_opt" with
              NONE => "ctable" <- (map_remove "cl_saddr" "ctbl")
            | SOME "_p" => #();;
                           "aux" "tl"
            end
        end
    end in
    "aux" "log_suf".

Definition reinit_view_change_data : val :=
  λ: "vc_data" "dvc_data",
  let: "vcpt" := Fst "vc_data" in
  let: "vl" := Snd "vc_data" in
  let: "qcpt" := Fst "dvc_data" in
  let: "ql" := Snd "dvc_data" in
  list_iter (λ: "p", "p" <- #false) "vl";;
  "vcpt" <- #0;;
  list_iter (λ: "p", "p" <- NONE) "ql";;
  "qcpt" <- #0.

Definition join_view : val :=
  λ: "lk" "i" "len" "viewC" "viewA" "status" "cmtN" "opN" "ptable" "ctable"
      "vc_data" "dvc_data" "log" "outQ" "newView",
  #() (* unsafe (print_step_state i "joining view" !viewC !status (!viewC mod len) !opN !cmtN !log); *);;
  let: "ki" := ! "cmtN" in
  let: "lg" := list_split ("ki" + #1) ! "log" in
  let: "pref" := Fst "lg" in
  let: "suf" := Snd "lg" in
  "opN" <- "ki";;
  "log" <- "pref";;
  ctbl_remove_pending "suf" "ctable";;
  reinit_view_change_data "vc_data" "dvc_data";;
  "ptable" <- (map_empty #());;
  "viewC" <- "newView";;
  "viewA" <- "newView";;
  "status" <- #true;;
  emit "lk" "outQ" (gst "newView" "ki" "i");;
  #() (* unsafe (print_step_state i "joined view" !viewC !status (!viewC mod len) !opN !cmtN !log) *).

Definition step_prp : val :=
  λ: "len" "i" "lk" "status" "viewC" "viewA" "opN" "cmtN" "log" "ptable"
      "ctable" "vc_data" "dvc_data" "db" "outQ" "prp",
  let: "vi" := ! "viewC" in
  let: "st" := ! "status" in
  let: "ni" := ! "opN" in
  let: "ki" := ! "cmtN" in
  let: "vj" := Fst (Fst (Fst "prp")) in
  let: "req" := Snd (Fst (Fst "prp")) in
  let: "nj" := Snd (Fst "prp") in
  let: "kj" := Snd "prp" in
  let: "vJ" := "vj" `rem` "len" in
  (if: "vi" ≤ "vj"
   then
     #() (* unsafe (print_step_state i "prp" vi st (vi mod len) ni ki !log); *);;
     assert: (~ ("vJ" = "i"));;
     (if: ("st" = #false) || ("vi" < "vj")
      then
        join_view "lk" "i" "len" "viewC" "viewA" "status" "cmtN" "opN"
        "ptable" "ctable" "vc_data" "dvc_data" "log" "outQ" "vj"
      else
        (if: "nj" ≤ "ni"
        then  #()
        else
          (if: "nj" = ("ni" + #1)
          then
            "opN" <- ("ni" + #1);;
            "log" <- (list_append ! "log" ["req"]);;
            let: "_op" := Fst (Fst "req") in
            let: "caddr" := Snd (Fst "req") in
            let: "seqid" := Snd "req" in
            "ctable" <- (map_insert "caddr" ("seqid", NONE) ! "ctable");;
            emit "lk" "outQ" (pok "vi" ("ni" + #1) "i");;
            let: "infl" := list_inf ("ki" + #1) "kj" ! "log" in
            commit_oplist_at_backup "cmtN" "ctable" "db" "infl"
          else  emit "lk" "outQ" (gst "vj" "ni" "i"))))
   else  #()).

Definition step_cmt : val :=
  λ: "len" "i" "lk" "status" "viewC" "viewA" "opN" "cmtN" "log" "ptable"
      "ctable" "vc_data" "dvc_data" "db" "outQ" "cmt",
  let: "vi" := ! "viewC" in
  let: "st" := ! "status" in
  let: "ni" := ! "opN" in
  let: "ki" := ! "cmtN" in
  let: "vj" := Fst "cmt" in
  let: "kj" := Snd "cmt" in
  let: "vJ" := "vj" `rem` "len" in
  (if: "vi" ≤ "vj"
   then
     assert: (~ ("vJ" = "i"));;
     (if: ("st" = #false) || ("vi" < "vj")
      then
        #() (* unsafe (print_step_state i "cmt" vi st (vi mod len) ni ki !log); *);;
        join_view "lk" "i" "len" "viewC" "viewA" "status" "cmtN" "opN"
        "ptable" "ctable" "vc_data" "dvc_data" "log" "outQ" "vj"
      else
        (if: "kj" ≤ "ni"
        then
          let: "infl" := list_inf ("ki" + #1) "kj" ! "log" in
          #() (* unsafe (fun () ->
              if not (list_is_empty infl)
              then print_step_state i "cmt" vi st (vi mod len) ni ki !log () *);;
          commit_oplist_at_backup "cmtN" "ctable" "db" "infl"
        else
          #() (* unsafe (print_step_state i "cmt" vi st (vi mod len) ni ki !log); *);;
          emit "lk" "outQ" (gst "vj" "ni" "i")))
   else  #()).

Definition process_prepareok_from_j : val :=
  λ: "cmtN" "ctable" "ptable" "db" "lk" "outQ" "pok" "log" "len",
  let: "vi" := Fst (Fst "pok") in
  let: "nj" := Snd (Fst "pok") in
  let: "j" := Snd "pok" in
  letrec: "aux" "l" "k" :=
    match: "l" with
      NONE => #()
    | SOME "p" =>
        let: "req" := Fst "p" in
        let: "tl" := Snd "p" in
        let: "ks" := "k" + #1 in
        let: "p" := unSOME (map_lookup "ks" ! "ptable") in
        let: "cpt" := Fst "p" in
        let: "okl" := Snd "p" in
        let: "okj" := unSOME (list_nth "okl" "j") in
        (if: ! "okj"
         then  "aux" "tl" "ks"
         else
           (if: (! "cpt" + #1) ≤ ("len" `quot` #2)
           then  "okj" <- #true;;
                 "cpt" <- (! "cpt" + #1);;
                 "aux" "tl" "ks"
           else
             let: "r" := commit_op "cmtN" "ctable" "db" "req" in
             let: "resp" := Fst (Fst "r") in
             let: "cl_addr" := Snd (Fst "r") in
             let: "seqid" := Snd "r" in
             "ptable" <- (map_remove "ks" ! "ptable");;
             emit_rpl "lk" "outQ" (rpl "vi" "seqid" "resp" "cl_addr");;
             "aux" "tl" "ks"))
    end in
    let: "ks" := ! "cmtN" + #1 in
    let: "infl" := list_inf "ks" "nj" ! "log" in
    "aux" "infl" ! "cmtN".

Definition step_pok : val :=
  λ: "len" "i" "lk" "status" "viewC" "opN" "cmtN" "log" "ptable" "ctable"
      "db" "outQ" "pok",
  let: "vi" := ! "viewC" in
  let: "st" := ! "status" in
  let: "ni" := ! "opN" in
  let: "ki" := ! "cmtN" in
  let: "vj" := Fst (Fst "pok") in
  let: "nj" := Snd (Fst "pok") in
  let: "j" := Snd "pok" in
  let: "vJ" := "vj" `rem` "len" in
  (if: "vi" = "vj"
   then
     assert: (("vJ" = "i") && (("st" = #true) && ("nj" ≤ "ni")));;
     (if: "ki" < "nj"
      then
        #() (* unsafe (print_step_state i "pok" vi st (vi mod len) ni ki !log); *);;
        let: "p" := unSOME (map_lookup "nj" ! "ptable") in
        let: "okj" := unSOME (list_nth (Snd "p") "j") in
        (if: ! "okj"
         then  #()
         else
           process_prepareok_from_j "cmtN" "ctable" "ptable" "db" "lk" "outQ"
           "pok" "log" "len")
      else  #())
   else  #()).

Definition add_request : val :=
  λ: "len" "i" "vi" "ki" "lk" "opN" "log" "ptable" "ctable" "outQ" "req",
  let: "op" := Fst (Fst "req") in
  let: "c" := Snd (Fst "req") in
  let: "s" := Snd "req" in
  let: "ni" := ! "opN" in
  "opN" <- ("ni" + #1);;
  "ctable" <- (map_insert "c" ("s", NONE) ! "ctable");;
  "log" <- (list_append ! "log" [("op", "c", "s")]);;
  add_ptable_entry "len" "ptable" "i" ("ni" + #1);;
  emit "lk" "outQ" (prp "vi" ("op", "c", "s") ("ni" + #1) "ki").

Definition step_req : val :=
  λ: "len" "i" "lk" "status" "viewC" "opN" "cmtN" "log" "ptable" "ctable"
      "outQ" "req",
  let: "vi" := ! "viewC" in
  let: "ki" := ! "cmtN" in
  let: "vI" := "vi" `rem` "len" in
  (if: ("vI" = "i") && (! "status" = #true)
   then
     let: "_op" := Fst (Fst "req") in
     let: "c" := Snd (Fst "req") in
     let: "s" := Snd "req" in
     match: map_lookup "c" ! "ctable" with
       NONE =>
       #() (* unsafe (print_step_state i "req" vi !status (vi mod len) !opN ki !log); *);;
       add_request "len" "i" "vi" "ki" "lk" "opN" "log" "ptable" "ctable"
       "outQ" "req"
     | SOME "p" =>
         let: "t" := Fst "p" in
         let: "ro" := Snd "p" in
         (if: "s" < "t"
          then  #()
          else
            match: "ro" with
             NONE => #()
           | SOME "res" =>
               #() (* unsafe (print_step_state i "req" vi !status (vi mod len) !opN ki !log); *);;
               (if: "s" = "t"
                then  emit_rpl "lk" "outQ" (rpl "vi" "s" "res" "c")
                else
                  add_request "len" "i" "vi" "ki" "lk" "opN" "log" "ptable"
                  "ctable" "outQ" "req")
           end)
     end
   else  #()).

(**  -------------------------------------------------------------------------  *)

(**  ------------------------- VIEW CHANGE PROTOCOL --------------------------  *)

(**  -------------------------------------------------------------------------  *)

Definition find_best_dvc : val :=
  rec: "find_best_dvc" "best" "l" "flag" :=
  match: "l" with
    NONE => "best"
  | SOME "p" =>
      let: "x" := Fst "p" in
      let: "tl" := Snd "p" in
      match: ! "x" with
        NONE => "find_best_dvc" "best" "tl" "flag"
      | SOME "qev" =>
          (if: "flag"
           then
             let: "b" := unSOME "best" in
             let: "_bl" := Fst (Fst (Fst "b")) in
             let: "bv" := Snd (Fst (Fst "b")) in
             let: "bn" := Snd (Fst "b") in
             let: "_bk" := Snd "b" in
             let: "_ql" := Fst (Fst (Fst "qev")) in
             let: "qv" := Snd (Fst (Fst "qev")) in
             let: "qn" := Snd (Fst "qev") in
             let: "_qk" := Snd "qev" in
             (if: "qv" < "bv"
              then  "find_best_dvc" "best" "tl" "flag"
              else
                (if: "bv" < "qv"
                then  "find_best_dvc" (SOME "qev") "tl" "flag"
                else
                  (if: "qn" ≤ "bn"
                  then  "find_best_dvc" "best" "tl" "flag"
                  else  "find_best_dvc" (SOME "qev") "tl" "flag")))
           else  "find_best_dvc" (SOME "qev") "tl" #true)
      end
  end.

Definition view_change_success : val :=
  λ: "len" "i" "lk" "status" "viewC" "viewA" "opN" "cmtN" "log" "ctable"
      "ptable" "vc_data" "dvc_data" "db" "outQ",
  #() (* unsafe (print_step_state i "install nv" !viewC !status (!viewC mod len) !opN !cmtN !log); *);;
  assert: ((! "viewC" `rem` "len") = "i");;
  #();;
  let: "_cpt" := Fst "dvc_data" in
  let: "vl" := Snd "dvc_data" in
  let: "newData" := find_best_dvc NONE "vl" #false in
  let: "b" := unSOME "newData" in
  let: "lb" := Fst (Fst (Fst "b")) in
  let: "vb" := Snd (Fst (Fst "b")) in
  let: "nb" := Snd (Fst "b") in
  let: "kb" := Snd "b" in
  let: "ki" := ! "cmtN" in
  let: "vi" := ! "viewC" in
  let: "li" := ! "log" in
  let: "k_max" := (if: "ki" ≤ "kb"
   then  "kb"
   else  "ki") in
  let: "split_li" := list_split ("k_max" + #1) "li" in
  let: "split_lb" := list_split ("k_max" + #1) "lb" in
  let: "lip" := Fst "split_li" in
  let: "lis" := Snd "split_li" in
  let: "lbp" := Fst "split_lb" in
  let: "lbs" := Snd "split_lb" in
  assert: ("lip" = "lbp");;
  assert: ("vb" = "vi");;
  "viewA" <- "vi";;
  "opN" <- "nb";;
  "log" <- (list_append "lip" "lbs");;
  "status" <- #true;;
  reinit_view_change_data "vc_data" "dvc_data";;
  ctbl_remove_pending "lis" "ctable";;
  ctbl_ptbl_add_pending "len" "i" "lbs" "ctable" "ptable" ("k_max" + #1);;
  emit "lk" "outQ" (snv "vi" "lb" "nb" ! "cmtN");;
  let: "infl" := list_inf "ki" "kb" ! "log" in
  commit_oplist_at_primary "cmtN" "ctable" "db" "infl" "vi" "lk" "outQ";;
  #() (* unsafe (print_step_state i "nv installed" !viewC !status (!viewC mod len) !opN !cmtN !log) *).

Definition add_dvc : val :=
  λ: "len" "i" "lk" "status" "viewC" "viewA" "opN" "cmtN" "log" "ctable"
      "ptable" "svc_data" "dvc_data" "db" "outQ" "dvc" "orig" "svc_flag",
  let: "qcpt" := Fst "dvc_data" in
  let: "ql" := Snd "dvc_data" in
  let: "tmp" := ! "qcpt" in
  let: "qtj" := unSOME (list_nth "ql" "orig") in
  match: ! "qtj" with
    SOME "_q" => #()
  | NONE =>
      "qcpt" <- ("tmp" + #1);;
      "qtj" <- (SOME "dvc");;
      (if: ("tmp" + #1) ≤ ("len" `quot` #2)
       then
         (if: "svc_flag"
         then  emit "lk" "outQ" (svc ! "viewC" "i")
         else  #())
       else
         view_change_success "len" "i" "lk" "status" "viewC" "viewA" "opN"
         "cmtN" "log" "ctable" "ptable" "svc_data" "dvc_data" "db" "outQ")
  end.

Definition add_svc : val :=
  λ: "len" "i" "lk" "vi" "va" "ni" "ki" "lg" "outQ" "svc_data" "orig"
      "svc_flag",
  let: "vcpt" := Fst "svc_data" in
  let: "vl" := Snd "svc_data" in
  let: "tmp" := ! "vcpt" in
  (if: ("len" `quot` #2) < "tmp"
   then  #()
   else
     let: "voteJ" := unSOME (list_nth "vl" "orig") in
     (if: ! "voteJ"
      then  #()
      else
        "voteJ" <- #true;;
        "vcpt" <- ("tmp" + #1);;
        (if: ("tmp" + #1) ≤ ("len" `quot` #2)
         then
           (if: "svc_flag"
           then  emit "lk" "outQ" (svc "vi" "i")
           else  #())
         else  emit "lk" "outQ" (dvc "vi" "lg" "va" "ni" "ki" "i")))).

Definition view_change_init_primary : val :=
  λ: "len" "lk" "i" "viewC" "viewA" "opN" "cmtN" "status" "log" "ctable"
      "ptable" "svc_data" "dvc_data" "db" "outQ" "newView" "trigger_event",
  add_dvc "len" "i" "lk" "status" "viewC" "viewA" "opN" "cmtN" "log" "ctable"
  "ptable" "svc_data" "dvc_data" "db" "outQ"
  (! "log", "newView", ! "opN", ! "cmtN") "i" #true;;
  match: "trigger_event" with
    NONE => #()
  | SOME "ev" =>
      match: "ev" with
        InjL "_orig" => #()
      | InjR "dvc_ev" =>
          let: "dvcj" := Fst "dvc_ev" in
          let: "j" := Snd "dvc_ev" in
          add_dvc "len" "i" "lk" "status" "viewC" "viewA" "opN" "cmtN" "log"
          "ctable" "ptable" "svc_data" "dvc_data" "db" "outQ" "dvcj" "j"
          #false
      end
  end.

Definition view_change_init_backup : val :=
  λ: "len" "lk" "i" "vi" "va" "ni" "ki" "lg" "svc_data" "outQ" "newView"
      "trigger_event",
  match: "trigger_event" with
    NONE =>
    add_svc "len" "i" "lk" "vi" "va" "ni" "ki" "lg" "outQ" "svc_data" "i"
    #true;;
    emit "lk" "outQ" (svc "newView" "i")
  | SOME "j" =>
      add_svc "len" "i" "lk" "vi" "va" "ni" "ki" "lg" "outQ" "svc_data" "j"
      #true
  end.

Definition view_change_init : val :=
  λ: "len" "lk" "i" "viewC" "viewA" "opN" "cmtN" "status" "log" "ctable"
      "ptable" "svc_data" "dvc_data" "db" "outQ" "newView" "trigger_event",
  "status" <- #false;;
  reinit_view_change_data "svc_data" "dvc_data";;
  "ptable" <- (map_empty #());;
  "viewC" <- "newView";;
  #() (* unsafe (print_step_state_vc i "vc init" !viewC !status (!viewC mod len) !opN !cmtN !log 0 0); *);;
  let: "vI" := "newView" `rem` "len" in
  (if: "vI" = "i"
   then
     view_change_init_primary "len" "lk" "i" "viewC" "viewA" "opN" "cmtN"
     "status" "log" "ctable" "ptable" "svc_data" "dvc_data" "db" "outQ"
     "newView" "trigger_event"
   else
     let: "trigger_event" := match: "trigger_event" with
       NONE => NONE
     | SOME "ev" =>
         match: "ev" with
           InjL "orig" => SOME "orig"
         | InjR "_dvc" => assert: #false
         end
     end in
     view_change_init_backup "len" "lk" "i" ! "viewC" ! "viewA" ! "opN"
     ! "cmtN" ! "log" "svc_data" "outQ" "newView" "trigger_event").

Definition step_svc : val :=
  λ: "len" "i" "lk" "status" "viewC" "viewA" "opN" "cmtN" "log" "ctable"
      "ptable" "svc_data" "dvc_data" "db" "outQ" "svc",
  let: "vi" := ! "viewC" in
  let: "st" := ! "status" in
  let: "vj" := Fst "svc" in
  let: "j" := Snd "svc" in
  let: "vI" := "vi" `rem` "len" in
  (if: "vi" < "vj"
   then
     #() (* unsafe (print_step_state i "svc" vi st (vi mod len) !opN !cmtN !log); *);;
     view_change_init "len" "lk" "i" "viewC" "viewA" "opN" "cmtN" "status"
     "log" "ctable" "ptable" "svc_data" "dvc_data" "db" "outQ" "vj"
     (SOME (InjL "j"))
   else
     (if: ("vj" < "vi") || "st"
     then  #()
     else
       (if: "vI" = "i"
       then  #()
       else
         add_svc "len" "i" "lk" ! "viewC" ! "viewA" ! "opN" ! "cmtN" ! "log"
         "outQ" "svc_data" "j" #false))).

Definition step_dvc : val :=
  λ: "len" "i" "lk" "viewC" "viewA" "opN" "cmtN" "status" "log" "ctable"
      "ptable" "svc_data" "dvc_data" "db" "outQ" "dvc",
  let: "vi" := ! "viewC" in
  let: "st" := ! "status" in
  let: "vj" := Fst (Fst (Fst (Fst (Fst "dvc")))) in
  let: "lj" := Snd (Fst (Fst (Fst (Fst "dvc")))) in
  let: "vaj" := Snd (Fst (Fst (Fst "dvc"))) in
  let: "nj" := Snd (Fst (Fst "dvc")) in
  let: "kj" := Snd (Fst "dvc") in
  let: "j" := Snd "dvc" in
  let: "vI" := "vi" `rem` "len" in
  let: "vJ" := "vj" `rem` "len" in
  (if: "vi" < "vj"
   then
     #() (* unsafe (print_step_state i "dvc" vi st (vi mod len) !opN !cmtN !log); *);;
     view_change_init "len" "lk" "i" "viewC" "viewA" "opN" "cmtN" "status"
     "log" "ctable" "ptable" "svc_data" "dvc_data" "db" "outQ" "vj"
     (SOME (InjR ("lj", "vaj", "nj", "kj", "j")))
   else
     (if: ("vj" < "vi") || "st"
     then  #()
     else
       #() (* unsafe (print_step_state i "dvc" vi st (vi mod len) !opN !cmtN !log); *);;
       assert: (("vJ" = "i") && ("vI" = "vJ"));;
       add_dvc "len" "i" "lk" "status" "viewC" "viewA" "opN" "cmtN" "log"
       "ctable" "ptable" "svc_data" "dvc_data" "db" "outQ"
       ("lj", "vaj", "nj", "kj") "j" #false)).

Definition step_snv : val :=
  λ: "len" "i" "lk" "viewC" "viewA" "opN" "cmtN" "status" "log" "ctable"
      "ptable" "svc_data" "dvc_data" "db" "outQ" "snv",
  let: "vi" := ! "viewC" in
  let: "st" := ! "status" in
  let: "ki" := ! "cmtN" in
  let: "li" := ! "log" in
  let: "vj" := Fst (Fst (Fst "snv")) in
  let: "lj" := Snd (Fst (Fst "snv")) in
  let: "nj" := Snd (Fst "snv") in
  let: "kj" := Snd "snv" in
  let: "vJ" := "vj" `rem` "len" in
  (if: (("vi" = "vj") && (~ "st")) || ("vi" < "vj")
   then
     #() (* unsafe (print_step_state i "snv start" vi st (vi mod len) !opN !cmtN !log); *);;
     assert: (~ ("vJ" = "i"));;
     let: "k_max" := (if: "ki" ≤ "kj"
      then  "kj"
      else  "ki") in
     let: "split_li" := list_split ("k_max" + #1) "li" in
     let: "split_lj" := list_split ("k_max" + #1) "lj" in
     let: "lip" := Fst "split_li" in
     let: "lis" := Snd "split_li" in
     let: "ljp" := Fst "split_lj" in
     let: "ljs" := Snd "split_lj" in
     assert: ("lip" = "ljp");;
     "viewC" <- "vj";;
     "viewA" <- "vj";;
     "opN" <- "nj";;
     "log" <- (list_append "lip" "ljs");;
     "status" <- #true;;
     "ptable" <- (map_empty #());;
     reinit_view_change_data "svc_data" "dvc_data";;
     ctbl_remove_pending "lis" "ctable";;
     ctbl_add_pending "ljs" "ctable";;
     (if: "nj" < "kj"
      then  emit "lk" "outQ" (pok "vj" "nj" "i")
      else  #());;
     let: "infl" := list_inf "ki" "kj" ! "log" in
     commit_oplist_at_backup "cmtN" "ctable" "db" "infl";;
     #() (* unsafe (print_step_state i "snv done" vi st (vi mod len) !opN !cmtN !log); *)
   else  #()).

(**  -------------------------------------------------------------------------  *)

(**  ---------------------- STATE TRANSFER PROCESSING ------------------------  *)

(**  -------------------------------------------------------------------------  *)

Definition step_gst : val :=
  λ: "len" "i" "lk" "viewC" "opN" "cmtN" "status" "log" "outQ" "gst",
  let: "vi" := ! "viewC" in
  let: "st" := ! "status" in
  let: "ni" := ! "opN" in
  let: "ki" := ! "cmtN" in
  let: "vj" := Fst (Fst "gst") in
  let: "nj" := Snd (Fst "gst") in
  let: "j" := Snd "gst" in
  let: "vJ" := "vj" `rem` "len" in
  (if: "vi" = "vj"
   then
     #() (* unsafe (print_step_state i "gst" vi st (vi mod len) !opN !cmtN !log); *);;
     assert: (("vJ" = "i") && (("st" = #true) && ("nj" ≤ "ni")));;
     (if: "nj" < "ni"
      then
        let: "lsuf" := list_suf ("nj" + #1) ! "log" in
        emit "lk" "outQ" (nst "vi" "lsuf" "ni" "ki" "j")
      else  #())
   else  #()).

Definition step_nst : val :=
  λ: "len" "i" "lk" "viewC" "opN" "cmtN" "status" "log" "ctable" "db" "outQ"
      "nst",
  let: "vi" := ! "viewC" in
  let: "st" := ! "status" in
  let: "ni" := ! "opN" in
  let: "ki" := ! "cmtN" in
  let: "vj" := Fst (Fst (Fst (Fst "nst"))) in
  let: "lj" := Snd (Fst (Fst (Fst "nst"))) in
  let: "nj" := Snd (Fst (Fst "nst")) in
  let: "kj" := Snd (Fst "nst") in
  let: "_j" := Snd "nst" in
  let: "vJ" := "vj" `rem` "len" in
  (if: "vi" = "vj"
   then
     #() (* unsafe (print_step_state i "nst" vi st (vi mod len) !opN !cmtN !log); *);;
     assert: ((~ ("vJ" = "i")) && ("st" = #true));;
     (if: "ni" < "nj"
      then
        let: "lnew" := list_inf "ni" "nj" "lj" in
        "log" <- (list_append ! "log" "lnew");;
        "opN" <- "nj";;
        ctbl_add_pending "lnew" "ctable";;
        emit "lk" "outQ" (pok "vi" "nj" "i");;
        let: "infl" := list_inf "ki" "kj" ! "log" in
        commit_oplist_at_backup "cmtN" "ctable" "db" "infl"
      else  #())
   else  #()).

(**  -------------------------------------------------------------------------  *)

(**  ------------------------------- EVENT LOOP ------------------------------  *)

(**  -------------------------------------------------------------------------  *)

Definition queue_length : val :=
  λ: "q", (list_length (Fst "q")) + (list_length (Snd "q")).

Definition fetch_from_network : val :=
  λ: "_i" "lk" "monitors" "inQ" "vi" "len",
  let: "vI" := "vi" `rem` "len" in
  let: "ev_opt" := (if: ~ (queue_is_empty ! "inQ")
   then
     acquire "lk";;
     let: "tmp" := ! "inQ" in
     (if: ~ (queue_is_empty "tmp")
      then
        let: "q" := unSOME (queue_take_opt "tmp") in
        let: "hd" := Fst "q" in
        let: "tl" := Snd "q" in
        "inQ" <- "tl";;
        #();;
        release "lk";;
        SOME "hd"
      else  NONE)
   else  NONE) in
  let: "mon" := ! (unSOME (list_nth "monitors" "vI")) in
  ("ev_opt", "mon").

Definition event_loop : val :=
  λ: "len" "i" "status" "viewC" "viewA" "opN" "cmtN" "log" "ctable" "ptable"
      "vc_data" "dvc_data" "db" "lk" "inQ" "outQ" "monitors" "shl",
  letrec: "loop" <> :=
    let: "vi" := ! "viewC" in
    let: "vI" := "vi" `rem` "len" in
    let: "ffn" := fetch_from_network "i" "lk" "monitors" "inQ" "vi" "len" in
    let: "ev_opt" := Fst "ffn" in
    let: "mon" := Snd "ffn" in
    (if: "mon"
     then  #()
     else
       (if: "vI" = "i"
       then
         (if: ! "status"
         then  emit "lk" "outQ" (cmt "vi" ! "cmtN")
         else  #())
       else
         let: "vI_next" := ("vi" + #1) `rem` "len" in
         let: "sh_old" := unSOME (list_nth "shl" "vI") in
         let: "sh_new" := unSOME (list_nth "shl" "vI_next") in
         SetReceiveTimeout "sh_old" #3 #0;;
         SetReceiveTimeout "sh_new" #15 #0;;
         #() (* unsafe (fun () -> Printf.eprintf "Noticed timeout! Changing views: %d to %d %!\n" vi (vi+1)); *);;
         view_change_init "len" "lk" "i" "viewC" "viewA" "opN" "cmtN"
         "status" "log" "ctable" "ptable" "vc_data" "dvc_data" "db" "outQ"
         ("vi" + #1) NONE));;
    #() (* unsafe ( fun () ->
      let vcpt = fst vc_data in
      let dcpt = fst dvc_data in
      if !status = false
      then
        print_step_state_vc i "event step" !viewC !status (!viewC mod len) !opN !cmtN !log !vcpt !dcpt () *);;
    match: "ev_opt" with
      NONE => #() (* unsafe (fun () -> Unix.sleepf 0.5); *);;
              "loop" #()
    | SOME "event" =>
        match: "event" with
          InjL "l___" =>
          match: "l___" with
            InjL "ll__" =>
            match: "ll__" with
              InjL "lll_" =>
              match: "lll_" with
                InjL "llll" =>
                step_prp "len" "i" "lk" "status" "viewC" "viewA" "opN" "cmtN"
                "log" "ptable" "ctable" "vc_data" "dvc_data" "db" "outQ"
                "llll"
              | InjR "lllr" =>
                  step_cmt "len" "i" "lk" "status" "viewC" "viewA" "opN"
                  "cmtN" "log" "ptable" "ctable" "vc_data" "dvc_data" "db"
                  "outQ" "lllr"
              end
            | InjR "llr_" =>
                match: "llr_" with
                  InjL "llrl" =>
                  step_pok "len" "i" "lk" "status" "viewC" "opN" "cmtN" "log"
                  "ptable" "ctable" "db" "outQ" "llrl"
                | InjR "llrr" =>
                    step_svc "len" "i" "lk" "status" "viewC" "viewA" "opN"
                    "cmtN" "log" "ctable" "ptable" "vc_data" "dvc_data" "db"
                    "outQ" "llrr"
                end
            end
          | InjR "lr__" =>
              match: "lr__" with
                InjL "lrl_" =>
                match: "lrl_" with
                  InjL "lrll" =>
                  step_dvc "len" "i" "lk" "viewC" "viewA" "opN" "cmtN"
                  "status" "log" "ctable" "ptable" "vc_data" "dvc_data" "db"
                  "outQ" "lrll"
                | InjR "lrlr" =>
                    step_snv "len" "i" "lk" "viewC" "viewA" "opN" "cmtN"
                    "status" "log" "ctable" "ptable" "vc_data" "dvc_data"
                    "db" "outQ" "lrlr"
                end
              | InjR "rr_" =>
                  match: "rr_" with
                    InjL "lrrl" =>
                    step_gst "len" "i" "lk" "viewC" "opN" "cmtN" "status"
                    "log" "outQ" "lrrl"
                  | InjR "lrrr" =>
                      step_nst "len" "i" "lk" "viewC" "opN" "cmtN" "status"
                      "log" "ctable" "db" "outQ" "lrrr"
                  end
              end
          end
        | InjR "r___" =>
            step_req "len" "i" "lk" "status" "viewC" "opN" "cmtN" "log"
            "ptable" "ctable" "outQ" "r___"
        end;;
        "loop" #()
    end in
    "loop" #().

(**  -------------------------------------------------------------------------  *)

(**  ----------------------- INITIALISATION PROCEDURE ------------------------  *)

(**  -------------------------------------------------------------------------  *)

Definition init val_ser : val :=
  λ: "cfg" "i",
  let: "cfg_i" := unSOME (list_nth "cfg" "i") in
  let: "len" := list_length "cfg_i" in
  let: "viewC" := ref #0 in
  let: "viewA" := ref #0 in
  let: "status" := ref #true in
  let: "log" := ref [] in
  let: "opN" := ref #-1 in
  let: "cmtN" := ref #-1 in
  let: "ctable" := ref (map_empty #()) in
  let: "ptable" := ref (map_empty #()) in
  let: "svc_data" := (ref #0, list_init "len" (λ: "_j", ref #false)) in
  let: "dvc_data" := (ref #0, list_init "len" (λ: "_j", ref NONE)) in
  let: "db" := ref (map_empty #()) in
  let: "netdata" := init_network val_ser "cfg" "i" in
  let: "lk" := Fst (Fst (Fst (Fst "netdata"))) in
  let: "inQ" := Snd (Fst (Fst (Fst "netdata"))) in
  let: "outQ" := Snd (Fst (Fst "netdata")) in
  let: "monitors" := Snd (Fst "netdata") in
  let: "shl" := Snd "netdata" in
  #() (* unsafe (print_first_line); *);;
  event_loop "len" "i" "status" "viewC" "viewA" "opN" "cmtN" "log" "ctable"
  "ptable" "svc_data" "dvc_data" "db" "lk" "inQ" "outQ" "monitors" "shl".
