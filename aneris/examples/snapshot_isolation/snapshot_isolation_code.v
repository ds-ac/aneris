(* This file is automatically generated from the OCaml source file
<repository_root>/ml_sources/examples/snapshot_isolation/snapshot_isolation_code.ml *)

From aneris.aneris_lang Require Import ast.
From aneris.aneris_lang.lib Require Import list_code.
From aneris.aneris_lang.lib Require Import map_code.
From aneris.aneris_lang.lib.serialization Require Import serialization_code.
From aneris.examples.reliable_communication.lib.mt_server Require Import mt_server_code.

(**  The internal state of the server  *)

Definition req_ser val_ser :=
  sum_serializer string_serializer
  (sum_serializer unit_serializer
   (prod_serializer int_serializer
    (list_serializer (prod_serializer string_serializer val_ser)))).

Definition repl_ser val_ser :=
  sum_serializer (option_serializer val_ser)
  (sum_serializer int_serializer bool_serializer).

Definition kvs_get : val :=
  λ: "k" "kvs",
  match: map_lookup "k" "kvs" with
    NONE => []
  | SOME "vlst" => assert: (~ ("vlst" = NONE));;
                   "vlst"
  end.

Definition kvs_get_last : val :=
  λ: "k" "kvs",
  let: "vlst" := kvs_get "k" "kvs" in
  match: "vlst" with
    NONE => NONE
  | SOME "vl" =>
      let: "v" := Fst (Fst "vl") in
      let: "_t" := Snd (Fst "vl") in
      let: "_oldl" := Snd "vl" in
      SOME "v"
  end.

Definition check_at_key : val :=
  λ: "ts" "tc" "_k" "vlst",
  match: "vlst" with
    NONE => #true
  | SOME "l" =>
      let: "vlast" := Fst "l" in
      let: "_hd" := Snd "l" in
      let: "_v" := Fst "vlast" in
      let: "t" := Snd "vlast" in
      (if: ("t" = "tc") || (("t" = "ts") || ("tc" < "t"))
       then  assert: #false
       else  "t" < "ts")
  end.

Definition update_kvs : val :=
  λ: "kvs" "cache" "tc",
  letrec: "upd" "kvs_t" "cache_t" :=
    match: "cache_t" with
      NONE => "kvs_t"
    | SOME "chl" =>
        let: "kv" := Fst "chl" in
        let: "cache_l" := Snd "chl" in
        let: "k" := Fst "kv" in
        let: "v" := Snd "kv" in
        let: "vlst" := kvs_get "k" "kvs" in
        let: "newval" := ("v", "tc") in
        let: "newvals" := "newval" :: "vlst" in
        let: "kvs_t'" := map_insert "k" "newvals" "kvs_t" in
        "upd" "kvs_t'" "cache_l"
    end in
    "upd" "kvs" "cache".

Definition commit_handler : val :=
  λ: "kvs" "cdata" "vnum" <>,
  let: "tc" := ! "vnum" + #1 in
  let: "kvs_t" := ! "kvs" in
  let: "ts" := Fst "cdata" in
  let: "cache" := Snd "cdata" in
  let: "b" := map_forall (λ: "k" "vlst", check_at_key "ts" "tc" "k" "vlst")
              "kvs_t" in
  (if: "b"
   then  "vnum" <- "tc";;
         "kvs" <- (update_kvs "kvs_t" "cache" "tc");;
         #true
   else  #false).

Definition lk_handle : val :=
  λ: "lk" "handler",
  acquire "lk";;
  let: "res" := "handler" #() in
  release "lk";;
  "res".

Definition read_handler : val := λ: "kvs" "k" <>, kvs_get_last "k" ! "kvs".

Definition start_handler : val :=
  λ: "vnum" <>, let: "vnext" := ! "vnum" + #1 in
                 "vnum" <- "vnext";;
                 "vnext".

Definition client_request_handler : val :=
  λ: "lk" "kvs" "vnum" "req",
  let: "res" := match: "req" with
    InjL "k" => InjL (lk_handle "lk" (read_handler "kvs" "k"))
  | InjR "r" =>
      match: "r" with
        InjL "_tt" => InjR (InjL (lk_handle "lk" (start_handler "vnum")))
      | InjR "cdata" =>
          InjR (InjR (lk_handle "lk" (commit_handler "kvs" "cdata" "vnum")))
      end
  end in
  "res".

Definition start_server_processing_clients ser : val :=
  λ: "addr" "lk" "kvs" "vnum" <>,
  run_server (repl_ser ser) (req_ser ser) "addr"
  (λ: "req", client_request_handler "lk" "kvs" "vnum" "req").

Definition init_server ser : val :=
  λ: "addr",
  let: "kvs" := ref (map_empty #()) in
  let: "lk" := newlock #() in
  let: "vnum" := ref #0 in
  Fork (start_server_processing_clients ser "addr" "lk" "kvs" "vnum" #()).

Definition init_client_proxy ser : val :=
  λ: "clt_addr" "srv_addr",
  let: "rpc" := init_client_proxy (req_ser ser) (repl_ser ser) "clt_addr"
                "srv_addr" in
  ("rpc", ref NONE).

Definition start : val :=
  λ: "cst",
  let: "rpc" := Fst "cst" in
  let: "tst" := Snd "cst" in
  match: ! "tst" with
    SOME "_abs" => assert: #false
  | NONE =>
      let: "repl" := make_request "rpc" (InjR (InjL #())) in
      match: "repl" with
        InjL "_abs" => assert: #false
      | InjR "s" =>
          match: "s" with
            InjL "ts" => "tst" <- (SOME ("ts", (ref (map_empty #()))))
          | InjR "_abs" => assert: #false
          end
      end
  end.

Definition read : val :=
  λ: "cst" "k",
  let: "rpc" := Fst "cst" in
  let: "tst" := Snd "cst" in
  match: ! "tst" with
    NONE => assert: #false
  | SOME "st" =>
      let: "_ts" := Fst "st" in
      let: "cache" := Snd "st" in
      match: map_lookup "k" ! "cache" with
        SOME "v" => SOME "v"
      | NONE =>
          let: "repl" := make_request "rpc" (InjL "k") in
          match: "repl" with
            InjL "vo" => "vo"
          | InjR "_abs" => assert: #false
          end
      end
  end.

Definition write : val :=
  λ: "cst" "k" "v",
  let: "_rpc" := Fst "cst" in
  let: "tst" := Snd "cst" in
  match: ! "tst" with
    NONE => assert: #false
  | SOME "st" =>
      let: "_ts" := Fst "st" in
      let: "cache" := Snd "st" in
      "cache" <- (map_insert "k" "v" ! "cache")
  end.

Definition commit : val :=
  λ: "cst",
  let: "rpc" := Fst "cst" in
  let: "tst" := Snd "cst" in
  match: ! "tst" with
    NONE => assert: #false
  | SOME "st" =>
      let: "ts" := Fst "st" in
      let: "cache" := Snd "st" in
      let: "repl" := make_request "rpc" (InjR (InjR ("ts", ! "cache"))) in
      match: "repl" with
        InjL "_abs" => assert: #false
      | InjR "r" =>
          match: "r" with
            InjL "_abs" => assert: #false
          | InjR "b" => "tst" <- NONE;;
                        "b"
          end
      end
  end.

Definition run : val :=
  λ: "cst" "handler", start "cst";;
                       "handler" "cst";;
                       commit "cst".
