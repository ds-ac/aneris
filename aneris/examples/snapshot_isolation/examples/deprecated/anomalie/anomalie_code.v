(* (* This file is automatically generated from the OCaml source file
<repository_root>/ml_sources/examples/snapshot_isolation/examples/deprecated/anomalie/anomalie_code.ml *)

From aneris.aneris_lang Require Import ast.
From aneris.aneris_lang.lib.serialization Require Import serialization_code.
From aneris.aneris_lang.lib Require Import network_util_code.
From aneris.aneris_lang.lib Require Import par_code.
From aneris.examples.snapshot_isolation Require Import snapshot_isolation_code.
From aneris.examples.snapshot_isolation.util Require Import util_code.

(**  From the paper https://www.cs.umb.edu/~poneil/ROAnom.pdf
    A Read-Only Transaction Anomaly Under Snapshot Isolation
    By Alan Fekete, Elizabeth O'Neil, and Patrick O'Neil


    Possible outcomes for checking the balance :

  .-----------------------------------------------------------------------------------.
  | Case  | commit-order |  read values of (x,y) | balance (y-x) | Consistency Model  |
  |-------|--------------|-----------------------|---------------|--------------------|
  |  C0   | [        ]   |       (0, 0)          |      0        |                    |
  |  C1   | [T1      ]   |       (0, 20)         |     20        |                    |
  |  C2   | [      T2]   |     (-11, 0)          |    -11        |  SERIALIZABILITY   |
  |  C3   | [T1 ;  T2]   |     (-10, 20)         |     10        |                    |
  |  C4   | [T2 ;  T1]   |     (-11, 20)         |      9        |                    |
  |-------|--------------|-----------------------|---------------|--------------------|
  |  C5   | [T1 ;  T2]   |     (-11, 20)         |      9        | SNAPSHOT ISOLATION |
  |-----------------------------------------------------------------------------------|

  .-----------------------------------------------------------------------------.
  |            Possible (unordered) pairs of read-only transactions             |
  |------------------------------------------------------|----------------------|
  |  ( Ci, Ci )              for i in [0,4]              |                      |
  |  ( C0, Ci )              for i in [1,4]              |                      |
  |  ( C1, C3 )                                          |     SERIALIZABLE     |
  |  ( C2, C4 )                                          |                      |
  |------------------------------------------------------|----------------------|
  |  ( C0, C5 )                                          |   NOT SERIALIZABLE   |
  |  ( C1, C5 )                                          |                      |
  |  ( C3, C5 )                                          |                      |
  |  ( C5, C5 )                                          |                      |
  |------------------------------------------------------|----------------------|
  |  ( C1, C2 )                                          |     NOT POSSIBLE     |
  |  ( C1, C4 )                                          |                      |
  |  ( C2, C3 )                                          |                      |
  |  ( C2, C5 )                                          |                      |
  |  ( C3, C4 )                                          |                      |
  |  ( C4, C5 )                                          |                      |
  |------------------------------------------------------|----------------------|

  T1: ----------------[ W(Y,20) ]---------------------------------------------------
  T2: [ R(X,0) R(Y,0)                                W(X,-11) ]---------------------
  T3: ----------------------------[ R(X,0) R(Y,20) ]--------------------------------
  T4: ----------------------------------------------------------[ R(X,-11) R(Y,20) ]


 *)

Definition tbody_init : val :=
  λ: "s", write "s" #"x" #0;;
           write "s" #"y" #0;;
           write "s" #"s0" #1.

Definition wait_s0 : val :=
  λ: "s", wait_on_key "s" (λ: "v", "v" = #1) #"s0".

Definition tbody_withdraw_ten : val :=
  λ: "s",
  #() (* unsafe (fun () ->
      Random.self_init ();
      let r = Random.int 5 in
      Printf.printf "%d\n%!" r;
      Unix.sleep r *);;
  wait_s0 "s";;
  let: "nx" := unSOME (read "s" #"x") in
  let: "ny" := unSOME (read "s" #"y") in
  let: "wdraw" := ("nx" + "ny") - #10 in
  (if: "wdraw" < #0
   then
     write "s" #"x" (("nx" - #10) - #1);;
     #() (* unsafe (fun () ->
        Printf.printf "Withdrawed from checking account with penalty! \n%!" *)
   else
     write "s" #"x" ("nx" - #10);;
     #() (* unsafe (fun () ->
        Printf.printf "Withdrawed from checking account without penalty. \n%!" *)).

Definition tbody_deposit_twenty : val :=
  λ: "s",
  #() (* unsafe (fun () ->
      Random.self_init ();
      let r = Random.int 5 in
      Printf.printf "%d\n%!" r;
      Unix.sleep r *);;
  wait_s0 "s";;
  write "s" #"y" #20;;
  #() (* unsafe (fun () -> Printf.printf "Deposited twenty on saving account. \n%!") *).

Definition tbody_check_account_1 : val :=
  λ: "r" "s",
  wait_s0 "s";;
  let: "n1" := unSOME (read "s" #"x") in
  let: "n2" := unSOME (read "s" #"y") in
  "r" <- ("n1", "n2").

Definition tbody_check_account_2 : val :=
  λ: "r" "s",
  wait_s0 "s";;
  let: "n1" := unSOME (read "s" #"x") in
  let: "n2" := unSOME (read "s" #"y") in
  "r" <- ("n1", "n2").

Definition node_init : val :=
  λ: "caddr" "kvs_addr", run_client "caddr" "kvs_addr" tbody_init.

Definition node_withdraw_ten : val :=
  λ: "caddr" "kvs_addr", run_client "caddr" "kvs_addr" tbody_withdraw_ten.

Definition node_deposit_twenty : val :=
  λ: "caddr" "kvs_addr", run_client "caddr" "kvs_addr" tbody_deposit_twenty.

Definition node_check_account : val :=
  λ: "caddr1" "caddr2" "kvs_addr",
  let: "r1" := ref (#0, #0) in
  let: "r2" := ref (#0, #0) in
  let: "_tt" := par (λ: <>,
                     #() (* unsafe (fun () -> Unix.sleepf 1.5); *);;
                     run_client "caddr1" "kvs_addr"
                     (tbody_check_account_1 "r1"))
                (λ: <>,
                 #() (* unsafe (fun () -> Unix.sleepf 3.0); *);;
                 run_client "caddr2" "kvs_addr" (tbody_check_account_2 "r2")) in
  let: "p1" := ! "r1" in
  let: "p2" := ! "r2" in
  let: "x1" := Fst "p1" in
  let: "y1" := Snd "p1" in
  let: "x2" := Fst "p2" in
  let: "y2" := Snd "p2" in
  #() (* unsafe (fun () -> Printf.printf "(x1,y1) = (%d, %d) \n%!" x1 y1); *);;
  #() (* unsafe (fun () -> Printf.printf "(x2,y2) = (%d, %d) \n%!" x2 y2) *).

Definition server : val :=
  λ: "srv",
  #() (* unsafe (fun () -> Printf.printf "Start server.\n%!"); *);;
  init_server int_serializer "srv";;
  #() (* unsafe (fun () -> Printf.printf "Server started.\n%!") *). *)
